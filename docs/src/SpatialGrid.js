var C=class{constructor({width:t,height:e,tileSize:s,debug:h=!1}){this.objects=[];this.debug=!1;this.lastCheckedTiles=[];this.#t=[];this.width=t,this.height=e,this.tileSize=s,this.debug=h}#t;add(...t){this.objects.push(...t)}remove(...t){this.objects=this.objects.filter(e=>!t.includes(e))}get xTiles(){return Math.floor(this.width/this.tileSize)}get yTiles(){return Math.floor(this.height/this.tileSize)}update(){this.#t=Array.from({length:this.xTiles*this.yTiles},()=>[]);for(let t of this.objects){let e=Math.floor((t.left??t.x-(t.radius??0))/this.tileSize),s=Math.floor((t.top??t.y-(t.radius??0))/this.tileSize),h=Math.floor((t.right??t.x+(t.radius??0))/this.tileSize),b=Math.floor((t.bottom??t.y+(t.radius??0))/this.tileSize);for(let n=e;n<=h;n++)for(let i=s;i<=b;i++)if(n>=0&&n<this.xTiles&&i>=0&&i<this.yTiles){let o=i*this.xTiles+n;this.#t[o].push(t)}}}getNeighbors(t,e,s=1){let h=new Set;this.debug&&(this.lastCheckedTiles=[]);let b=Math.floor(t/this.tileSize),n=Math.floor(e/this.tileSize);for(let i=-s;i<=s;i++)for(let o=-s;o<=s;o++){let c=b+i,r=n+o;if(c>=0&&c<this.xTiles&&r>=0&&r<this.yTiles){this.debug&&this.lastCheckedTiles.push({x:c,y:r});let l=r*this.xTiles+c;for(let f of this.#t[l])h.add(f)}}return Array.from(h)}getObjectsIntersectingCircle(t,e,s){this.debug&&(this.lastCheckedTiles=[]);let h=this.getNeighbors(t,e,Math.ceil(s/this.tileSize)),b=[];for(let n of h){let i=n.radius||0,o=n.x-t,c=n.y-e,r=o*o+c*c,l=i+s;r<=l*l&&b.push(n)}return b}getObjectsIntersectingRect(t,e,s,h){this.debug&&(this.lastCheckedTiles=[]);let b=[],n=Math.floor(t/this.tileSize),i=Math.floor(e/this.tileSize),o=Math.floor((t+s)/this.tileSize),c=Math.floor((e+h)/this.tileSize);for(let r=n;r<=o;r++)for(let l=i;l<=c;l++)if(r>=0&&r<this.xTiles&&l>=0&&l<this.yTiles){this.debug&&this.lastCheckedTiles.push({x:r,y:l});let f=l*this.xTiles+r;for(let d of this.#t[f]){let p=d.left??d.x,m=d.right??d.x,y=d.top??d.y,j=d.bottom??d.y;m>=t&&p<=t+s&&j>=e&&y<=e+h&&b.push(d)}}return b}getObjectsIntersectingLine(t,e,s,h,b=0){this.debug&&(this.lastCheckedTiles=[]);let n=new Set,i=Math.floor(t/this.tileSize),o=Math.floor(e/this.tileSize),c=Math.floor(s/this.tileSize),r=Math.floor(h/this.tileSize),l=Math.abs(c-i),f=Math.abs(r-o),d=i<c?1:-1,p=o<r?1:-1,m=l-f;for(;i>=0&&i<this.xTiles&&o>=0&&o<this.yTiles&&(n.add({x:i,y:o}),this.debug&&this.lastCheckedTiles.push({x:i,y:o})),!(i===c&&o===r);){let a=2*m;a>-f&&(m-=f,i+=d),a<l&&(m+=l,o+=p)}let y=new Set,j=Math.ceil(b/(2*this.tileSize));for(let a of n)for(let x=-j;x<=j;x++)for(let u=-j;u<=j;u++){let g=a.x+x,S=a.y+u;g>=0&&g<this.xTiles&&S>=0&&S<this.yTiles&&(y.add({x:g,y:S}),this.debug&&this.lastCheckedTiles.push({x:g,y:S}))}let T=new Set;for(let a of y){let x=a.y*this.xTiles+a.x;for(let u of this.#t[x])T.add(u)}let G=Array.from(T),M=[],w=(s-t)**2+(h-e)**2;for(let a of G){let x=a.radius||0,u=a.x,g=a.y,S=Math.max(0,Math.min(1,((u-t)*(s-t)+(g-e)*(h-e))/w)),I=t+S*(s-t),R=e+S*(h-e),z=u-I,O=g-R,q=z*z+O*O,k=x+b/2;q<=k*k&&M.push(a)}return M}};export{C as SpatialGrid};
